import{d as e,m as t}from"../nitro/nitro.mjs";import{T as r,Z as n}from"../_/index.mjs";import{r as o,f as s,g as i,i as a,a as c}from"../_/router.mjs";import{t as p,c as u,a as m,s as d,i as h,f,b as l,d as y,e as v,v as O}from"../_/client.DwfV9Oyl.mjs";import{S,g as P,s as g}from"../_/openapi-client.D3eD5ojB.mjs";import"node:events";import"node:process";import"cloudflare:workers";import"node:buffer";import"node:timers";import"@prisma/client";import"node:util";const I=Symbol("ORPC_OPERATION_EXTENDER");function getCustomOpenAPIOperation(e){return e[I]}function applyCustomOpenAPIOperation(e,t){const r=[];for(const e of Object.values(t["~orpc"].errorMap)){const t=e?getCustomOpenAPIOperation(e):void 0;t&&r.push(t)}if(a(t))for(const e of t["~orpc"].middlewares){const t=getCustomOpenAPIOperation(e);t&&r.push(t)}let n=e;for(const e of r)n="function"==typeof e?e(n,t):{...n,...e};return n}const b=["$dynamicRef","$ref","additionalItems","additionalProperties","allOf","anyOf","const","contains","contentEncoding","contentMediaType","contentSchema","dependencies","dependentRequired","dependentSchemas","else","enum","exclusiveMaximum","exclusiveMinimum","format","if","items","maxContains","maximum","maxItems","maxLength","maxProperties","minContains","minimum","minItems","minLength","minProperties","multipleOf","not","oneOf","pattern","patternProperties","prefixItems","properties","propertyNames","required","then","type","unevaluatedItems","unevaluatedProperties","uniqueItems"];function isFileSchema(e){return y(e)&&"string"===e.type&&"string"==typeof e.contentMediaType}function isObjectSchema(e){return y(e)&&"object"===e.type}function filterSchemaBranches(e,t,r=[]){if(t(e))return r.push(e),[r,void 0];if(y(e))for(const n of["anyOf","oneOf"])if(e[n]&&Object.keys(e).every(e=>e===n||!b.includes(e))){const o=e[n].map(e=>filterSchemaBranches(e,t,r)[1]).filter(e=>!!e);return 1===o.length&&"object"==typeof o[0]?[r,{...e,[n]:void 0,...o[0]}]:[r,{...e,[n]:o}]}return[r,e]}function applySchemaOptionality(e,t){return e?t:{anyOf:[t,{not:{}}]}}function expandUnionSchema(e){if("object"==typeof e)for(const t of["anyOf","oneOf"])if(e[t]&&Object.keys(e).every(e=>e===t||!b.includes(e)))return e[t].flatMap(e=>expandUnionSchema(e));return[e]}function expandArrayableSchema(e){const t=expandUnionSchema(e);if(2!==t.length)return;const r=t.find(e=>"object"==typeof e&&"array"===e.type&&Object.keys(e).filter(e=>b.includes(e)).every(e=>"type"===e||"items"===e));if(void 0===r)return;const n=r.items,o=t.find(e=>e!==r);return d(n)===d(o)?[o,r]:void 0}const w=new Set([r.String,r.Number,r.Integer,r.Boolean,r.Null]);function isPrimitiveSchema(e){return expandUnionSchema(e).every(e=>"boolean"!=typeof e&&(!("string"!=typeof e.type||!w.has(e.type))||void 0!==e.const))}function toOpenAPIPath(e){return g(e).replace(/\/\{\+([^}]+)\}/g,"/{$1}")}function toOpenAPIMethod(e){return e.toLocaleLowerCase()}function toOpenAPIContent(e){const t={},[r,n]=filterSchemaBranches(e,isFileSchema);for(const e of r)t[e.contentMediaType]={schema:toOpenAPISchema(e)};if(void 0!==n){t["application/json"]={schema:toOpenAPISchema(n)};v(e=>y(e)&&isFileSchema(e),n).values.length>0&&(t["multipart/form-data"]={schema:toOpenAPISchema(n)})}return t}function toOpenAPIEventIteratorContent([e,t],[r,n]){return{"text/event-stream":{schema:toOpenAPISchema({oneOf:[{type:"object",properties:{event:{const:"message"},data:t,id:{type:"string"},retry:{type:"number"}},required:e?["event","data"]:["event"]},{type:"object",properties:{event:{const:"done"},data:n,id:{type:"string"},retry:{type:"number"}},required:r?["event","data"]:["event"]},{type:"object",properties:{event:{const:"error"},data:{},id:{type:"string"},retry:{type:"number"}},required:["event"]}]})}}}function toOpenAPIParameters(e,t){const r=[];for(const n in e.properties){const o=e.properties[n];let s=!0;if("query"!==t)s=!1;else if(isPrimitiveSchema(o))s=!1;else{const[e]=expandArrayableSchema(o)??[];void 0!==e&&isPrimitiveSchema(e)&&(s=!1)}r.push({name:n,in:t,required:e.required?.includes(n),schema:toOpenAPISchema(o),style:s?"deepObject":void 0,explode:!!s||void 0,allowEmptyValue:"query"===t||void 0,allowReserved:"query"===t||void 0})}return r}function checkParamsSchema(e,t){const r=Object.keys(e.properties??{}),n=e.required??[];return r.length===t.length&&!r.some(e=>!t.includes(e))&&(n.length===t.length&&!n.some(e=>!t.includes(e)))}function toOpenAPISchema(e){return!0===e?{}:!1===e?{not:{}}:e}const A="#/components/schemas/";function resolveOpenAPIJsonSchemaRef(e,t){if("object"!=typeof t||!t.$ref?.startsWith(A))return t;const r=t.$ref.slice(21),n=e.components?.schemas?.[r];return n??t}class CompositeSchemaConverter{converters;constructor(e){this.converters=e}async convert(e,t){for(const r of this.converters)if(await r.condition(e,t))return r.convert(e,t);return[!1,{}]}}class OpenAPIGeneratorError extends Error{}class OpenAPIGenerator{serializer;converter;constructor(e={}){this.serializer=new S(e),this.converter=new CompositeSchemaConverter(p(e.schemaConverters))}async generate(e,t={}){const r=t.filter??(({contract:e,path:r})=>!t.exclude?.(e,r)),n={...u(t),info:t.info??{title:"API Reference",version:"0.0.0"},openapi:"3.1.1",exclude:void 0,filter:void 0,commonSchemas:void 0},{baseSchemaConvertOptions:i,undefinedErrorJsonSchema:a}=await this.#e(n,t.commonSchemas),c=[];await o({path:[],router:e},e=>{O(r,e)&&c.push(e)});const p=[];for(const{contract:e,path:t}of c){const r=t.join(".");try{const o=e["~orpc"],c=toOpenAPIMethod(s("defaultMethod",o.route.method)),p=toOpenAPIPath(o.route.path??m(t));let u;void 0!==o.route.spec?u=o.route.spec:(u={operationId:r,summary:o.route.summary,description:o.route.description,deprecated:o.route.deprecated,tags:o.route.tags?.map(e=>e)},await this.#t(n,u,o,i),await this.#r(n,u,o,i),await this.#n(u,o,i,a)),n.paths??={},n.paths[p]??={},n.paths[p][c]=applyCustomOpenAPIOperation(u,e)}catch(e){if(!(e instanceof OpenAPIGeneratorError))throw e;p.push(`[OpenAPIGenerator] Error occurred while generating OpenAPI for procedure at path: ${r}\n${e.message}`)}}if(p.length)throw new OpenAPIGeneratorError(`Some error occurred during OpenAPI generation:\n\n${p.join("\n\n")}`);return this.serializer.serialize(n)[0]}async#e(e,t){let r={type:"object",properties:{defined:{const:!1},code:{type:"string"},status:{type:"number"},message:{type:"string"},data:{}},required:["defined","code","status","message"]};const n={};if(t){n.components=[];for(const e in t){const r=t[e];if(void 0===r.schema)continue;const{schema:o,strategy:s="input"}=r,[i,a]=await this.converter.convert(o,{strategy:s}),c=[s];if("input"===s){const[e,t]=await this.converter.convert(o,{strategy:"output"});e===i&&d(t)===d(a)&&c.push("output")}else if("output"===s){const[e,t]=await this.converter.convert(o,{strategy:"input"});e===i&&d(t)===d(a)&&c.push("input")}n.components.push({schema:o,required:i,ref:`#/components/schemas/${e}`,allowedStrategies:c})}e.components??={},e.components.schemas??={};for(const o in t){const s=t[o];if(void 0===s.schema){"UndefinedError"===s.error&&(e.components.schemas[o]=toOpenAPISchema(r),r={$ref:`#/components/schemas/${o}`});continue}const{schema:i,strategy:a="input"}=s,[,c]=await this.converter.convert(i,{...n,strategy:a,minStructureDepthForRef:1});e.components.schemas[o]=toOpenAPISchema(c)}}return{baseSchemaConvertOptions:n,undefinedErrorJsonSchema:r}}async#t(e,t,r,n){const o=s("defaultMethod",r.route.method),a=i(r.inputSchema);if(a)return void(t.requestBody={required:!0,content:toOpenAPIEventIteratorContent(await this.converter.convert(a.yields,{...n,strategy:"input"}),await this.converter.convert(a.returns,{...n,strategy:"input"}))});const c=P(r.route.path)?.map(e=>e.name),p=s("defaultInputStructure",r.route.inputStructure);let[u,m]=await this.converter.convert(r.inputSchema,{...n,strategy:"input",minStructureDepthForRef:c?.length||"detailed"===p?1:0});if(function(e){return!0===e||!!Object.keys(e).every(e=>!b.includes(e))}(m)&&!c?.length)return;if("compact"===p){if(c?.length){const e=new OpenAPIGeneratorError('When input structure is "compact", and path has dynamic params, input schema must be an object with all dynamic params as required.');if(!isObjectSchema(m))throw e;const[r,n]=function(e,t){if(Object.keys(e).some(e=>"type"!==e&&"properties"!==e&&"required"!==e&&b.includes(e)))return[{type:"object"},e];const r={...e},n={...e};return r.properties=e.properties&&Object.entries(e.properties).filter(([e])=>t.includes(e)).reduce((e,[t,r])=>(e[t]=r,e),{}),r.required=e.required?.filter(e=>t.includes(e)),r.examples=e.examples?.map(e=>y(e)?Object.entries(e).reduce((e,[r,n])=>(t.includes(r)&&(e[r]=n),e),{}):e),n.properties=e.properties&&Object.entries(e.properties).filter(([e])=>!t.includes(e)).reduce((e,[t,r])=>(e[t]=r,e),{}),n.required=e.required?.filter(e=>!t.includes(e)),n.examples=e.examples?.map(e=>y(e)?Object.entries(e).reduce((e,[r,n])=>(t.includes(r)||(e[r]=n),e),{}):e),[r,n]}(m,c);if(m=n,u=!!n.required&&0!==n.required.length,!checkParamsSchema(r,c))throw e;t.parameters??=[],t.parameters.push(...toOpenAPIParameters(r,"path"))}if("GET"===o){if(!isObjectSchema(m))throw new OpenAPIGeneratorError('When method is "GET", input schema must satisfy: object | any | unknown');t.parameters??=[],t.parameters.push(...toOpenAPIParameters(m,"query"))}else t.requestBody={required:u,content:toOpenAPIContent(m)};return}const d=new OpenAPIGeneratorError('When input structure is "detailed", input schema must satisfy: { params?: Record<string, unknown>, query?: Record<string, unknown>, headers?: Record<string, unknown>, body?: unknown }');if(!isObjectSchema(m))throw d;const h=void 0!==m.properties?.params?resolveOpenAPIJsonSchemaRef(e,m.properties.params):void 0;if(c?.length&&(void 0===h||!isObjectSchema(h)||!checkParamsSchema(h,c)))throw new OpenAPIGeneratorError('When input structure is "detailed" and path has dynamic params, the "params" schema must be an object with all dynamic params as required.');for(const r of["params","query","headers"]){const n=m.properties?.[r];if(void 0!==n){const o=resolveOpenAPIJsonSchemaRef(e,n);if(!isObjectSchema(o))throw d;const s="params"===r?"path":"headers"===r?"header":"query";t.parameters??=[],t.parameters.push(...toOpenAPIParameters(o,s))}}void 0!==m.properties?.body&&(t.requestBody={required:m.required?.includes("body"),content:toOpenAPIContent(m.properties.body)})}async#r(e,t,r,n){const o=r.outputSchema,a=s("defaultSuccessStatus",r.route.successStatus),c=s("defaultSuccessDescription",r.route?.successDescription),p=i(o),u=s("defaultOutputStructure",r.route.outputStructure);if(p)return t.responses??={},void(t.responses[a]={description:c,content:toOpenAPIEventIteratorContent(await this.converter.convert(p.yields,{...n,strategy:"output"}),await this.converter.convert(p.returns,{...n,strategy:"output"}))});const[m,f]=await this.converter.convert(o,{...n,strategy:"output",minStructureDepthForRef:"detailed"===u?1:0});if("compact"===u)return t.responses??={},t.responses[a]={description:c},void(t.responses[a].content=toOpenAPIContent(applySchemaOptionality(m,f)));const l=new Set;for(const r of expandUnionSchema(f)){const n=new OpenAPIGeneratorError(`\n        When output structure is "detailed", output schema must satisfy:\n        { \n          status?: number, // must be a literal number and in the range of 200-399\n          headers?: Record<string, unknown>, \n          body?: unknown \n        }\n        \n        But got: ${d(r)}\n      `);if(!isObjectSchema(r))throw n;let o,s;if(void 0!==r.properties?.status){const t=resolveOpenAPIJsonSchemaRef(e,r.properties.status);if("object"!=typeof t||void 0===t.const||"number"!=typeof t.const||!Number.isInteger(t.const)||h(t.const))throw n;o=t.const,s=t.description}const i=o??a,p=s??c;if(l.has(i))throw new OpenAPIGeneratorError(`\n          When output structure is "detailed", each success status must be unique.\n          But got status: ${i} used more than once.\n        `);if(l.add(i),t.responses??={},t.responses[i]={description:p},void 0!==r.properties?.headers){const o=resolveOpenAPIJsonSchemaRef(e,r.properties.headers);if(!isObjectSchema(o))throw n;for(const e in o.properties){const n=o.properties[e];void 0!==n&&(t.responses[i].headers??={},t.responses[i].headers[e]={schema:toOpenAPISchema(n),required:r.required?.includes("headers")&&o.required?.includes(e)})}}void 0!==r.properties?.body&&(t.responses[i].content=toOpenAPIContent(applySchemaOptionality(r.required?.includes("body")??!1,r.properties.body)))}}async#n(e,t,r,n){const o=t.errorMap,s={};for(const e in o){const t=o[e];if(!t)continue;const n=f(e,t.status),i=l(e,t.message),[a,c]=await this.converter.convert(t.data,{...r,strategy:"output"});s[n]??=[],s[n].push({type:"object",properties:{defined:{const:!0},code:{const:e},status:{const:n},message:{type:"string",default:i},data:c},required:a?["defined","code","status","message","data"]:["defined","code","status","message"]})}e.responses??={};for(const t in s){const r=s[t];e.responses[t]={description:t,content:toOpenAPIContent({oneOf:[...r,n]})}}}}const j=e(async()=>{const e=new OpenAPIGenerator({schemaConverters:[new n]});return await e.generate(c,{info:{title:"zxcv API",version:"1.0.0",description:"AI Coding Rules Management Platform API"},servers:[{url:`${t.env.FRONTEND_URL||"http://localhost:3000"}/api`,description:"API Server"}]})});export{j as default};
//# sourceMappingURL=api-spec.json.mjs.map
