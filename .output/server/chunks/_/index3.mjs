import{S as t,t as e,h as r,g as s,O as n,k as o,p as a,N as i,v as c,a as d,q as h,r as p}from"./client.DwfV9Oyl.mjs";import{t as u,a as l}from"./index4.mjs";import{j as m,t as f,i as g,u as w,e as P,h as R,f as S}from"./router.mjs";class CompositeStandardHandlerPlugin{plugins;constructor(t=[]){this.plugins=[...t].sort((t,e)=>(t.order??0)-(e.order??0))}init(t,e){for(const r of this.plugins)r.init?.(t,e)}}class StandardHandler{constructor(t,r,s,n){this.matcher=r,this.codec=s;new CompositeStandardHandlerPlugin(n.plugins).init(n,t),this.interceptors=e(n.interceptors),this.clientInterceptors=e(n.clientInterceptors),this.rootInterceptors=e(n.rootInterceptors),this.matcher.init(t)}interceptors;clientInterceptors;rootInterceptors;async handle(t,e){const a=e.prefix?.replace(/\/$/,"")||void 0;return a&&!t.url.pathname.startsWith(`${a}/`)&&t.url.pathname!==a?{matched:!1,response:void 0}:r(this.rootInterceptors,{...e,request:t,prefix:a},async t=>{let e=!1;try{return await r(this.interceptors,t,async({request:t,context:r,prefix:n})=>{const o=t.method,a=t.url,i=n?a.pathname.replace(n,""):a.pathname,c=await this.matcher.match(o,`/${i.replace(/^\/|\/$/g,"")}`);if(!c)return{matched:!1,response:void 0};const d=m(c.procedure,{context:r,path:c.path,interceptors:this.clientInterceptors});e=!0;const h=await this.codec.decode(t,c.params,c.procedure);e=!1;const p=await d(h,{signal:t.signal,lastEventId:s(t.headers["last-event-id"])});return{matched:!0,response:this.codec.encode(p,c.procedure)}})}catch(t){const r=!e||t instanceof n?o(t):new n("BAD_REQUEST",{message:"Malformed request. Ensure the request body is properly formatted and the 'Content-Type' header is set correctly.",cause:t});return{matched:!0,response:this.codec.encodeError(r)}}})}}class StandardRPCCodec{constructor(t){this.serializer=t}async decode(t,e,r){const s="GET"===t.method?h(t.url.searchParams.getAll("data").at(-1)):await t.body();return this.serializer.deserialize(s)}encode(t,e){return{status:200,headers:{},body:this.serializer.serialize(t)}}encodeError(t){return{status:t.status,headers:{},body:this.serializer.serialize(t.toJSON())}}}class StandardRPCMatcher{filter;tree=new i;pendingRouters=[];constructor(t={}){this.filter=t.filter??!0}init(t,e=[]){const r=f({router:t,path:e},e=>{if(!c(this.filter,e))return;const{path:r,contract:s}=e,n=d(r);g(s)?this.tree[n]={path:r,contract:s,procedure:s,router:t}:this.tree[n]={path:r,contract:s,procedure:void 0,router:t}});this.pendingRouters.push(...r.map(t=>({...t,httpPathPrefix:d(t.path)})))}async match(t,e){if(this.pendingRouters.length){const t=[];for(const r of this.pendingRouters)if(e.startsWith(r.httpPathPrefix)){const{default:t}=await w(r.router);this.init(t,r.path)}else t.push(r);this.pendingRouters=t}const r=this.tree[e];if(r){if(!r.procedure){const{default:t}=await w(P(r.router,r.path));if(!g(t))throw new Error(`\n          [Contract-First] Missing or invalid implementation for procedure at path: ${d(r.path)}.\n          Ensure that the procedure is correctly defined and matches the expected contract.\n        `);r.procedure=R(t,r.contract)}return{path:r.path,procedure:r.procedure}}}}class StandardRPCHandler extends StandardHandler{constructor(e,r={}){const s=new t(r),n=new a(s);super(e,new StandardRPCMatcher(r),new StandardRPCCodec(n),r)}}const x=Symbol("STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT");class StrictGetMethodPlugin{error;order=7e6;constructor(t={}){this.error=t.error??new n("METHOD_NOT_SUPPORTED")}init(t){t.rootInterceptors??=[],t.clientInterceptors??=[],t.rootInterceptors.unshift(t=>{const e="GET"===t.request.method;return t.next({...t,context:{...t.context,[x]:e}})}),t.clientInterceptors.unshift(t=>{if("boolean"!=typeof t.context[x])throw new TypeError("[StrictGetMethodPlugin] strict GET method context has been corrupted or modified by another plugin or interceptor");const e=S("defaultMethod",t.procedure["~orpc"].route.method);if(t.context[x]&&"GET"!==e)throw this.error;return t.next()})}}class CompositeFetchHandlerPlugin extends CompositeStandardHandlerPlugin{initRuntimeAdapter(t){for(const e of this.plugins)e.initRuntimeAdapter?.(t)}}class FetchHandler{constructor(t,r={}){this.standardHandler=t;new CompositeFetchHandlerPlugin(r.plugins).initRuntimeAdapter(r),this.adapterInterceptors=e(r.adapterInterceptors),this.toFetchResponseOptions=r}toFetchResponseOptions;adapterInterceptors;async handle(t,...e){return r(this.adapterInterceptors,{...(s=p(e),{...s,context:s.context??{}}),request:t,toFetchResponseOptions:this.toFetchResponseOptions},async({request:t,toFetchResponseOptions:e,...r})=>{const s=u(t),n=await this.standardHandler.handle(s,r);return n.matched?{matched:!0,response:l(n.response,e)}:n});var s}}class RPCHandler extends FetchHandler{constructor(t,e={}){(e.strictGetMethodPluginEnabled??1)&&(e.plugins??=[],e.plugins.push(new StrictGetMethodPlugin)),super(new StandardRPCHandler(t,e),e)}}export{FetchHandler as F,RPCHandler as R,StandardHandler as S};
//# sourceMappingURL=index3.mjs.map
