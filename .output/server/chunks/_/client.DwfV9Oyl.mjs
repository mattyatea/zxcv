function resolveMaybeOptionalOptions(t){return t[0]??{}}function toArray(t){return Array.isArray(t)?t:null==t?[]:[t]}function once(t){let r;return()=>{if(r)return r.result;const s=t();return r={result:s},s}}function isAsyncIteratorObject(t){return!(!t||"object"!=typeof t)&&("next"in t&&"function"==typeof t.next&&Symbol.asyncIterator in t&&"function"==typeof t[Symbol.asyncIterator])}const t=Symbol.for("asyncDispose"),r=Symbol.asyncDispose??t;class AsyncIteratorClass{#e=!1;#t=!1;#r;#s;constructor(t,r){this.#r=r,this.#s=function(t){let r=Promise.resolve();return(...s)=>r=r.catch(()=>{}).then(()=>t(...s))}(async()=>{if(this.#e)return{done:!0,value:void 0};try{const r=await t();return r.done&&(this.#e=!0),r}catch(t){throw this.#e=!0,t}finally{this.#e&&!this.#t&&(this.#t=!0,await this.#r("next"))}})}next(){return this.#s()}async return(t){return this.#e=!0,this.#t||(this.#t=!0,await this.#r("return")),{done:!0,value:t}}async throw(t){throw this.#e=!0,this.#t||(this.#t=!0,await this.#r("throw")),t}async[r](){this.#e=!0,this.#t||(this.#t=!0,await this.#r("dispose"))}[Symbol.asyncIterator](){return this}}function onError(t){return async(r,...s)=>{try{return await r.next()}catch(n){throw await t(n,r,...s),n}}}function intercept(t,r,s){const next=(r,n)=>{const a=t[n];return a?a({...r,next:(t=r)=>next(t,n+1)}):s(r)};return next(r,0)}function parseEmptyableJSON(t){if(t)return JSON.parse(t)}function stringifyJSON(t){return JSON.stringify(t)}function findDeepMatches(t,r,s=[],n=[],a=[]){if(t(r))n.push(s),a.push(r);else if(Array.isArray(r))r.forEach((r,o)=>{findDeepMatches(t,r,[...s,o],n,a)});else if(isObject(r))for(const o in r)findDeepMatches(t,r[o],[...s,o],n,a);return{maps:n,values:a}}function isObject(t){if(!t||"object"!=typeof t)return!1;const r=Object.getPrototypeOf(t);return r===Object.prototype||!r||!r.constructor}function isTypescriptObject(t){return!!t&&("object"==typeof t||"function"==typeof t)}function clone(t){if(Array.isArray(t))return t.map(clone);if(isObject(t)){const r={};for(const s in t)r[s]=clone(t[s]);return r}return t}const s=(()=>{const e=function(){};return e.prototype=Object.create(null),Object.freeze(e.prototype),e})();function value(t,...r){return"function"==typeof t?t(...r):t}class EventEncoderError extends TypeError{}class EventDecoderError extends TypeError{}class ErrorEvent extends Error{data;constructor(t){super(t?.message??"An error event was received",t),this.data=t?.data}}function decodeEventMessage(t){const r=t.replace(/\n+$/,"").split(/\n/),s={data:void 0,event:void 0,id:void 0,retry:void 0,comments:[]};for(const t of r){const r=t.indexOf(":"),n=-1===r?t:t.slice(0,r),a=-1===r?"":t.slice(r+1).replace(/^\s/,"");if(0===r)s.comments.push(a);else if("data"===n)s.data??="",s.data+=`${a}\n`;else if("event"===n)s.event=a;else if("id"===n)s.id=a;else if("retry"===n){const t=Number.parseInt(a);Number.isInteger(t)&&t>=0&&t.toString()===a&&(s.retry=t)}}return s.data=s.data?.replace(/\n$/,""),s}class EventDecoder{constructor(t={}){this.options=t}incomplete="";feed(t){this.incomplete+=t;const r=this.incomplete.lastIndexOf("\n\n");if(-1===r)return;const s=this.incomplete.slice(0,r).split(/\n\n/);this.incomplete=this.incomplete.slice(r+2);for(const t of s){const r=decodeEventMessage(`${t}\n\n`);this.options.onEvent&&this.options.onEvent(r)}this.incomplete=""}end(){if(this.incomplete)throw new EventDecoderError("Event Iterator ended before complete")}}class EventDecoderStream extends TransformStream{constructor(){let t;super({start(r){t=new EventDecoder({onEvent:t=>{r.enqueue(t)}})},transform(r){t.feed(r)},flush(){t.end()}})}}function assertEventId(t){if(t.includes("\n"))throw new EventEncoderError("Event's id must not contain a newline character")}function assertEventRetry(t){if(!Number.isInteger(t)||t<0)throw new EventEncoderError("Event's retry must be a integer and >= 0")}function assertEventComment(t){if(t.includes("\n"))throw new EventEncoderError("Event's comment must not contain a newline character")}function encodeEventMessage(t){let r="";return r+=function(t){let r="";for(const s of t??[])assertEventComment(s),r+=`: ${s}\n`;return r}(t.comments),void 0!==t.event&&(!function(t){if(t.includes("\n"))throw new EventEncoderError("Event's event must not contain a newline character")}(t.event),r+=`event: ${t.event}\n`),void 0!==t.retry&&(assertEventRetry(t.retry),r+=`retry: ${t.retry}\n`),void 0!==t.id&&(assertEventId(t.id),r+=`id: ${t.id}\n`),r+=function(t){const r=t?.split(/\n/)??[];let s="";for(const t of r)s+=`data: ${t}\n`;return s}(t.data),r+="\n",r}const n=Symbol("ORPC_EVENT_SOURCE_META");function withEventMeta(t,r){if(void 0!==r.id&&assertEventId(r.id),void 0!==r.retry&&assertEventRetry(r.retry),void 0!==r.comments)for(const t of r.comments)assertEventComment(t);return new Proxy(t,{get:(t,s,a)=>s===n?r:Reflect.get(t,s,a)})}function getEventMeta(t){return isTypescriptObject(t)?Reflect.get(t,n):void 0}function generateContentDisposition(t){return`inline; filename="${t.replace(/"/g,'\\"')}"; filename*=utf-8''${encodeURIComponent(t).replace(/['()*]/g,t=>`%${t.charCodeAt(0).toString(16).toUpperCase()}`).replace(/%(7C|60|5E)/g,(t,r)=>String.fromCharCode(Number.parseInt(r,16)))}`}function getFilenameFromContentDisposition(t){const r=t.match(/filename\*=(UTF-8'')?([^;]*)/i);if(r&&"string"==typeof r[2])return decodeURIComponent(r[2]);const s=t.match(/filename="((?:\\"|[^"])*)"/i);return s&&"string"==typeof s[1]?s[1].replace(/\\"/g,'"'):void 0}function flattenHeader(t){return"string"==typeof t||void 0===t?t:0!==t.length?t.join(", "):void 0}const a={BAD_REQUEST:{status:400,message:"Bad Request"},UNAUTHORIZED:{status:401,message:"Unauthorized"},FORBIDDEN:{status:403,message:"Forbidden"},NOT_FOUND:{status:404,message:"Not Found"},METHOD_NOT_SUPPORTED:{status:405,message:"Method Not Supported"},NOT_ACCEPTABLE:{status:406,message:"Not Acceptable"},TIMEOUT:{status:408,message:"Request Timeout"},CONFLICT:{status:409,message:"Conflict"},PRECONDITION_FAILED:{status:412,message:"Precondition Failed"},PAYLOAD_TOO_LARGE:{status:413,message:"Payload Too Large"},UNSUPPORTED_MEDIA_TYPE:{status:415,message:"Unsupported Media Type"},UNPROCESSABLE_CONTENT:{status:422,message:"Unprocessable Content"},TOO_MANY_REQUESTS:{status:429,message:"Too Many Requests"},CLIENT_CLOSED_REQUEST:{status:499,message:"Client Closed Request"},INTERNAL_SERVER_ERROR:{status:500,message:"Internal Server Error"},NOT_IMPLEMENTED:{status:501,message:"Not Implemented"},BAD_GATEWAY:{status:502,message:"Bad Gateway"},SERVICE_UNAVAILABLE:{status:503,message:"Service Unavailable"},GATEWAY_TIMEOUT:{status:504,message:"Gateway Timeout"}};function fallbackORPCErrorStatus(t,r){return r??a[t]?.status??500}function fallbackORPCErrorMessage(t,r){return r||a[t]?.message||t}class ORPCError extends Error{defined;code;status;data;constructor(t,...[r]){if(r?.status&&!isORPCErrorStatus(r.status))throw new Error("[ORPCError] Invalid error status code.");super(fallbackORPCErrorMessage(t,r?.message),r),this.code=t,this.status=fallbackORPCErrorStatus(t,r?.status),this.defined=r?.defined??!1,this.data=r?.data}toJSON(){return{defined:this.defined,code:this.code,status:this.status,message:this.message,data:this.data}}}function toORPCError(t){return t instanceof ORPCError?t:new ORPCError("INTERNAL_SERVER_ERROR",{message:"Internal server error",cause:t})}function isORPCErrorStatus(t){return t<200||t>=400}function isORPCErrorJson(t){if(!isObject(t))return!1;const r=["defined","code","status","message","data"];return!Object.keys(t).some(t=>!r.includes(t))&&("defined"in t&&"boolean"==typeof t.defined&&"code"in t&&"string"==typeof t.code&&"status"in t&&"number"==typeof t.status&&isORPCErrorStatus(t.status)&&"message"in t&&"string"==typeof t.message)}function createORPCErrorFromJson(t,r={}){return new ORPCError(t.code,{...r,...t})}function mapEventIterator(t,r){return new AsyncIteratorClass(async()=>{const{done:s,value:n}=await(async()=>{try{return await t.next()}catch(t){let s=await r.error(t);if(s!==t){const r=getEventMeta(t);r&&isTypescriptObject(s)&&(s=withEventMeta(s,r))}throw s}})();let a=await r.value(n,s);if(a!==n){const t=getEventMeta(n);t&&isTypescriptObject(a)&&(a=withEventMeta(a,t))}return{done:s,value:a}},async()=>{await(t.return?.())})}class CompositeStandardLinkPlugin{plugins;constructor(t=[]){this.plugins=[...t].sort((t,r)=>(t.order??0)-(r.order??0))}init(t){for(const r of this.plugins)r.init?.(t)}}class StandardLink{constructor(t,r,s={}){this.codec=t,this.sender=r;new CompositeStandardLinkPlugin(s.plugins).init(s),this.interceptors=toArray(s.interceptors),this.clientInterceptors=toArray(s.clientInterceptors)}interceptors;clientInterceptors;call(t,r,s){return intercept(this.interceptors,{...s,path:t,input:r},async({path:t,input:r,...s})=>await this.#n(t,r,s))}async#n(t,r,s){const n=await this.codec.encode(t,r,s),a=await intercept(this.clientInterceptors,{...s,input:r,path:t,request:n},({input:t,path:r,request:s,...n})=>this.sender.call(s,n,r,t));return await this.codec.decode(a,s,t,r)}}const o=0,i=1,c=2,u=3,l=4,d=5,f=6,h=7;class StandardRPCJsonSerializer{customSerializers;constructor(t={}){if(this.customSerializers=t.customJsonSerializers??[],this.customSerializers.length!==new Set(this.customSerializers.map(t=>t.type)).size)throw new Error("Custom serializer type must be unique.")}serialize(t,r=[],s=[],n=[],a=[]){for(const o of this.customSerializers)if(o.condition(t)){const i=this.serialize(o.serialize(t),r,s,n,a);return s.push([o.type,...r]),i}if(t instanceof Blob)return n.push(r),a.push(t),[t,s,n,a];if("bigint"==typeof t)return s.push([o,...r]),[t.toString(),s,n,a];if(t instanceof Date)return s.push([i,...r]),Number.isNaN(t.getTime())?[null,s,n,a]:[t.toISOString(),s,n,a];if(Number.isNaN(t))return s.push([c,...r]),[null,s,n,a];if(t instanceof URL)return s.push([l,...r]),[t.toString(),s,n,a];if(t instanceof RegExp)return s.push([d,...r]),[t.toString(),s,n,a];if(t instanceof Set){const o=this.serialize(Array.from(t),r,s,n,a);return s.push([f,...r]),o}if(t instanceof Map){const o=this.serialize(Array.from(t.entries()),r,s,n,a);return s.push([h,...r]),o}if(Array.isArray(t)){return[t.map((t,o)=>void 0===t?(s.push([u,...r,o]),t):this.serialize(t,[...r,o],s,n,a)[0]),s,n,a]}if(isObject(t)){const o={};for(const i in t)"toJSON"===i&&"function"==typeof t[i]||(o[i]=this.serialize(t[i],[...r,i],s,n,a)[0]);return[o,s,n,a]}return[t,s,n,a]}deserialize(t,r,s,n){const a={data:t};s&&n&&s.forEach((t,r)=>{let s=a,o="data";t.forEach(t=>{s=s[o],o=t}),s[o]=n(r)});for(const t of r){const r=t[0];let s=a,n="data";for(let r=1;r<t.length;r++)s=s[n],n=t[r];for(const t of this.customSerializers)if(t.type===r){s[n]=t.deserialize(s[n]);break}switch(r){case o:s[n]=BigInt(s[n]);break;case i:s[n]=new Date(s[n]??"Invalid Date");break;case c:s[n]=Number.NaN;break;case u:s[n]=void 0;break;case l:s[n]=new URL(s[n]);break;case d:{const[,t,r]=s[n].match(/^\/(.*)\/([a-z]*)$/);s[n]=new RegExp(t,r);break}case f:s[n]=new Set(s[n]);break;case h:s[n]=new Map(s[n])}}return a.data}}function toHttpPath(t){return`/${t.map(encodeURIComponent).join("/")}`}class StandardRPCLinkCodec{constructor(t,r){this.serializer=t,this.baseUrl=r.url,this.maxUrlLength=r.maxUrlLength??2083,this.fallbackMethod=r.fallbackMethod??"POST",this.expectedMethod=r.method??this.fallbackMethod,this.headers=r.headers??{}}baseUrl;maxUrlLength;fallbackMethod;expectedMethod;headers;async encode(t,r,s){const n=await value(this.expectedMethod,s,t,r);let a=await value(this.headers,s,t,r);const o=await value(this.baseUrl,s,t,r),i=new URL(o);i.pathname=`${i.pathname.replace(/\/$/,"")}${toHttpPath(t)}`,void 0!==s.lastEventId&&(a=function(t,r){const s={...t};for(const t in r)Array.isArray(r[t])?s[t]=[...toArray(s[t]),...r[t]]:void 0!==r[t]&&(Array.isArray(s[t])?s[t]=[...s[t],r[t]]:void 0!==s[t]?s[t]=[s[t],r[t]]:s[t]=r[t]);return s}(a,{"last-event-id":s.lastEventId}));const c=this.serializer.serialize(r);if(!("GET"!==n||c instanceof FormData||isAsyncIteratorObject(c))){const o=await value(this.maxUrlLength,s,t,r),u=new URL(i);if(u.searchParams.append("data",stringifyJSON(c)),u.toString().length<=o)return{body:void 0,method:n,headers:a,url:u,signal:s.signal}}return{url:i,method:"GET"===n?this.fallbackMethod:n,headers:a,body:c,signal:s.signal}}async decode(t){const r=!isORPCErrorStatus(t.status),s=await(async()=>{let r=!1;try{const s=await t.body();return r=!0,this.serializer.deserialize(s)}catch(t){if(!r)throw new Error("Cannot parse response body, please check the response body and content-type.",{cause:t});throw new Error("Invalid RPC response format.",{cause:t})}})();if(!r){if(isORPCErrorJson(s))throw createORPCErrorFromJson(s);throw new ORPCError((n=t.status,Object.entries(a).find(([,t])=>t.status===n)?.[0]??"MALFORMED_ORPC_ERROR_RESPONSE"),{status:t.status,data:{...t,body:s}})}var n;return s}}class StandardRPCSerializer{constructor(t){this.jsonSerializer=t}serialize(t){return isAsyncIteratorObject(t)?mapEventIterator(t,{value:async t=>this.#a(t,!1),error:async t=>new ErrorEvent({data:this.#a(toORPCError(t).toJSON(),!1),cause:t})}):this.#a(t,!0)}#a(t,r){const[s,n,a,o]=this.jsonSerializer.serialize(t),i=0===n.length?void 0:n;if(!r||0===o.length)return{json:s,meta:i};const c=new FormData;return c.set("data",stringifyJSON({json:s,meta:i,maps:a})),o.forEach((t,r)=>{c.set(r.toString(),t)}),c}deserialize(t){return isAsyncIteratorObject(t)?mapEventIterator(t,{value:async t=>this.#o(t),error:async t=>{if(!(t instanceof ErrorEvent))return t;const r=this.#o(t.data);return isORPCErrorJson(r)?createORPCErrorFromJson(r,{cause:t}):new ErrorEvent({data:r,cause:t})}}):this.#o(t)}#o(t){if(!(t instanceof FormData))return this.jsonSerializer.deserialize(t.json,t.meta??[]);const r=JSON.parse(t.get("data"));return this.jsonSerializer.deserialize(r.json,r.meta??[],r.maps,r=>t.get(r.toString()))}}class StandardRPCLink extends StandardLink{constructor(t,r){const s=new StandardRPCJsonSerializer(r),n=new StandardRPCSerializer(s);super(new StandardRPCLinkCodec(n,r),t,r)}}export{getFilenameFromContentDisposition as A,EventDecoderStream as B,AsyncIteratorClass as C,isTypescriptObject as D,ErrorEvent as E,withEventMeta as F,s as N,ORPCError as O,StandardRPCJsonSerializer as S,toHttpPath as a,fallbackORPCErrorMessage as b,clone as c,isObject as d,findDeepMatches as e,fallbackORPCErrorStatus as f,flattenHeader as g,intercept as h,isORPCErrorStatus as i,isAsyncIteratorObject as j,toORPCError as k,isORPCErrorJson as l,mapEventIterator as m,createORPCErrorFromJson as n,onError as o,StandardRPCSerializer as p,parseEmptyableJSON as q,resolveMaybeOptionalOptions as r,stringifyJSON as s,toArray as t,StandardRPCLink as u,value as v,once as w,generateContentDisposition as x,encodeEventMessage as y,getEventMeta as z};
//# sourceMappingURL=client.DwfV9Oyl.mjs.map
